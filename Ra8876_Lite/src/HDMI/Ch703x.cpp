/**
* @brief    Driver for Chrontel CH7033B HDMI encoder
* @file     Ch703x.h
* @author   John Leung @ TechToys (www.TechToys.com.hk)
* @section  HISTORY
* Date      22nd May 2017 First release <br>
* 
* @note
* Reference: <br>
* https://github.com/TeamWin/android_kernel_kazam_thunder_q45/tree/master/mediatek/custom/common/kernel/hdmi/ch7035<br>
* The first one is highly correlated. <br>
* https://github.com/EMGD-Community/intel-binaries-linux/tree/master/drm/emgd/pal/ch7036<br>
* https://chromium.googlesource.com/chromiumos/third_party/chrontel/+/0.12.433.B/ch7036_access.c<br>
*/

#include "Ch703x.h"

CH703X HDMI_Tx;

/**
* @brief	HAL level hardware setup specific for a certain platform.
*/
void CH703X::hal_hwSetup()
{
#if defined (_VARIANT_ARDUINO_DUE_X_) && (WIRE_INTERFACES_COUNT>1)
	_i2c = &Wire1;
#else
	_i2c = &Wire;
#endif

	_i2c->begin();
	//pinMode(CH703X_IRQ, INPUT_PULLUP);	
}

/**
* @brief	HAL level register write to a slave device @ CH703X_SLAVE_ADDR.
*         CH703X_SLAVE_ADDR is defined in ch703x.h
*			    Example :
*			    //write 0x01 to register 0x03
*			    hal_writeRegister(0x03, 0x01);	
* @param	index is the register address
* @param	val is the value to write.
*/
void CH703X::hal_writeRegister(uint8_t index, uint8_t val)
{
    _i2c->beginTransmission(CH703X_SLAVE_ADDR);
    _i2c->write(index);
    _i2c->write(val);
    _i2c->endTransmission();
}

/**
* @brief	HAL level register read from a slave device @ CH703X_SLAVE_ADDR 
*			    CH703X_SLAVE_ADDR is defined in ch703x.h
*			    Example :
*			    uint8_t test_value = hal_readRegister(0x03);	

* @param	index is the register address to read
* @return value to read from register at index
*/
uint8_t CH703X::hal_readRegister(uint8_t index)
{
	_i2c->beginTransmission(CH703X_SLAVE_ADDR);
	_i2c->write(index);
	_i2c->endTransmission(false);	///STOP condition is not sent after the base address
	_i2c->requestFrom(CH703X_SLAVE_ADDR, 1);

	while(_i2c->available()<1)
		;
	
    uint8_t val = _i2c->read();    

    return val;
}

 /**
 *	@brief	HAL level software delay
 *	@param	ms is the delay in millisec
 */
 void CH703X::hal_delayMs(uint32_t ms)
 {
	 delay(ms);
 }

/**
 * @brief Set register page to access. There are 4 pages: 1,2,3,&4
 * @param page is the page number
 */
void CH703X::setRegisterPage(uint8_t page)
{
  if      (page==1)
    hal_writeRegister(0x03, 0);
  else if (page==2)
    hal_writeRegister(0x03, 1);
  else if (page==3)
    hal_writeRegister(0x03, 3);
  else if (page==4)
    hal_writeRegister(0x03, 4); 
}

/**
* @brief Write to the register a value <val> on page <page>
* @param page is the page (1,2,3,4) to write
* @param index is the register address
* @param val is the value to write
*/
void CH703X::writeRegister(uint8_t page, uint8_t index, uint8_t val)
{
	setRegisterPage(page);
	hal_writeRegister(index, val);
}

/**
* @brief	Register read from a slave device @ CH703X_SLAVE_ADDR
* @param	page is the page number (1,2,3,4) to read from
* @param	index is the register address
* @param	val is the pointer to an array holding the value read.
* @param	count is the number of byte to read
*/
void CH703X::readRegister(uint8_t page, uint8_t index, uint8_t *val, uint8_t count)
{
	setRegisterPage(page);

	for(uint8_t i=0; i<count; i++)
		*val++ = hal_readRegister(index+i);
}

const char* CH703X::yesno (int v)
{
  return v? "yes" : "no";
}

/**
*@brief This function resets all control registers to the default values.
*@note  Control registers are also reset at power on by an internally
*       generated power on reset signal.
*/
void CH703X::resetIB(void)
{
  uint8_t REG_R1_4Eh;

  readRegister(1, 0x4E, &REG_R1_4Eh, 1);

  setRegisterPage(4);
  hal_writeRegister(0x52, 0xC3);  //reset IB and hold data path
  hal_writeRegister(0x52, 0xC1);
  hal_writeRegister(0x52, 0xC3);

  setRegisterPage(1);
  hal_writeRegister(0x1C, 0x69);  //MCU clock to 27MHz
  hal_writeRegister(0x1D, 0x78);  //REG[69h]:REG[78h]=0x6978=27000

  hal_writeRegister(0x4E, REG_R1_4Eh|0x40); //???

  writeRegister(2, 0x1E, 9);  //???
}

/**
*@brief This function resets the data path.
*@note  reset the data path is like reseting the MCU of ch703x.
*/
void CH703X::resetDB(void)
{
  setRegisterPage(4);

  uint8_t REG_R4_52h = hal_readRegister(0x52);
  hal_writeRegister(0x52, REG_R4_52h & 0xFE);
  hal_writeRegister(0x52, REG_R4_52h | 0x01);
  setRegisterPage(1);
}

/**
* @brief Initialize CH703x and power it up with video in & out parameters 
* @param lcdParamInOut[][2] is a 2-D array generated by an offline tool provided by Chrontel
*/
bool CH703X::init(const uint8_t lcdParamInOut[][2])
{
  uint32_t i, val_t=0;
  uint32_t hinc_reg, hinca_reg, hincb_reg;
  uint32_t vinc_reg, vinca_reg, vincb_reg;
  uint32_t hdinc_reg, hdinca_reg, hdincb_reg;

  //get the size of register table
  while(lcdParamInOut[val_t++][0]!=0x7F)
  ;
  //printf("Table size = %d\n", val_t);

  //1. write register table
  for(i=0; i<val_t; ++i)
  {
    hal_writeRegister(lcdParamInOut[i][0], lcdParamInOut[i][1]);
    //printf("Register writing: %x, value: %x\n", lcdParamInOut[i][0],lcdParamInOut[i][1]);
  }

  hal_writeRegister(0x03, 0x01);  //page 2
  hal_writeRegister(0x4F, 0xC0);  //match I2S_LENGTH[1:0] of 0b00
  
  //2. calculate online parameters
  hal_writeRegister(0x03, 0x00);  //page 1 
  i = hal_readRegister(0x25);
  hal_writeRegister(0x03, 4);     //page 4
  //HINCA:
  val_t = hal_readRegister(0x2A);
  hinca_reg = (val_t << 3) | (hal_readRegister(0x2B) & 0x07);
  //HINCB:
  val_t = hal_readRegister(0x2C);
  hincb_reg = (val_t << 3) | (hal_readRegister(0x2D) & 0x07);
  //VINCA:
  val_t = hal_readRegister(0x2E);
  vinca_reg = (val_t << 3) | (hal_readRegister(0x2F) & 0x07);
  //VINCB:
  val_t = hal_readRegister(0x30);
  vincb_reg = (val_t << 3) | (hal_readRegister(0x31) & 0x07);
  //HDINCA:
  val_t = hal_readRegister(0x32);
  hdinca_reg = (val_t << 3) | (hal_readRegister(0x33) & 0x07);
  //HDINCB:
  val_t = hal_readRegister(0x34);
  hdincb_reg = (val_t << 3) | (hal_readRegister(0x35) & 0x07);
  //no calculate hdinc if down sample disabled
  if(i & (1 << 6))
  {
    if(hdincb_reg == 0)
    {
      printf("Err: hdincb_reg==0\n");
      return false;
    }
    hdinc_reg = (uint32_t)(((uint64_t)hdinca_reg) * (1 << 20) / hdincb_reg);
    hal_writeRegister(0x3C, (hdinc_reg >> 16) & 0xFF);
    hal_writeRegister(0x3D, (hdinc_reg >>  8) & 0xFF);
    hal_writeRegister(0x3E, (hdinc_reg >>  0) & 0xFF);
  }
  if(hincb_reg == 0 || vincb_reg == 0)
  {
    printf("Err: hincb_reg==0 or vincb_reg==0\n");
    return false;
  }
  if(hinca_reg > hincb_reg)
  {
    printf("Err: hinca_reg > hincb_reg\n");
    return false;
  }
  hinc_reg = (uint32_t)((uint64_t)hinca_reg * (1 << 20) / hincb_reg);
  vinc_reg = (uint32_t)((uint64_t)vinca_reg * (1 << 20) / vincb_reg);
  hal_writeRegister(0x36, (hinc_reg >> 16) & 0xFF);
  hal_writeRegister(0x37, (hinc_reg >>  8) & 0xFF);
  hal_writeRegister(0x38, (hinc_reg >>  0) & 0xFF);
  hal_writeRegister(0x39, (vinc_reg >> 16) & 0xFF);
  hal_writeRegister(0x3A, (vinc_reg >>  8) & 0xFF);
  hal_writeRegister(0x3B, (vinc_reg >>  0) & 0xFF);

  //3. Start to running:
  hal_writeRegister(0x03, 0x00);
  val_t = hal_readRegister(0x0A);         //Power state register 4
  hal_writeRegister(0x0A, val_t | 0x80);  //MEMINIT bit set 1->0 to end SDRAM init end
  hal_writeRegister(0x0A, val_t & 0x7F);  //MEMINIT = R1_0Ah[7]
  val_t = hal_readRegister(0x0A);
  hal_writeRegister(0x0A, val_t & 0xEF);  //STOP bit set 0, SDRAM start to read
  hal_writeRegister(0x0A, val_t | 0x10);  //STOP bit set 1, SDRAM stop read
  hal_writeRegister(0x0A, val_t & 0xEF);  //STOP bit set 0, SDRAM start reading again

  printf("CH703X start running from here...\n");
  return true;
}
    
/**
* @brief  Initialize CH703x and power it up with video in & out timing parameters in run time.
* @param  *videoIn is a pointer to video in from the RGB source.
* @param  *videoOut is a pointer to video out generated by CH703x.
* @param  monitorType indicates if it is a VGA, HDTV, HDMI, or DVI output.
* @note	  This one not working yet. Please use bool init(const uint8_t lcdParamInOut[][2]) instead
*/
/*
bool CH703X::init(const LCDParam *videoIn, const LCDParam *videoOut, uint8_t monitorType)
{
	setInputHorizontalTotal(videoIn->width + videoIn->hblank);
	setInputHsyncActiveWidth(videoIn->width);
	setInputHsyncFrontPorch(videoIn->hfporch);
	setInputHsyncPulseWidth(videoIn->hpulse);

	setInputVerticalTotal(videoIn->height + videoIn->vblank);
	setInputVsyncActiveHeight(videoIn->height);
	setInputVsyncFrontPorch(videoIn->vfporch);
	setInputVsyncPulseWidth(videoIn->vpulse);

	setInputPclkFrequency((videoIn->pclk)*1000);
	setInputSyncPolarity(videoIn->hsyncPolarity, videoIn->vsyncPolarity, videoIn->dePolarity);

	return true;
}
*/

/**
*
*/
void CH703X::begin(void)
{
	hal_hwSetup();
	//resetDB();
	if(!_initialised)
	{
		_initialised = true;
	}
}

    /**
    * @brief    Make function call to writeRegister() & readRegister() from a serial terminal. 
    * @param    *msg is a pointer to incoming message in ASCII characters. 
    * @note     Prerequisite : Serial.begin(baudrate) in setup()<br>
    *           Example to use:<br>
    *           In Arduino, open Serial Monitor, type in the following commands and click <send><br>
    *           i2c,w,1,0x7f,0x14	//i2c write to page 1 at register 0x7F a value 0x14.<br>
    *           This is to switch on color color test in CH7035B.<br>
    *           i2c,r,2,0x10,1      //i2c read from page 2 at register address 0x10 a single byte.<br>
    *           i2c,edid            //read EDID of a monitor.<br>
    */
void CH703X::parser(char *msg)
{
  char *token = NULL;
  bool isWriteCommand = false;
  const char delimiters[] = ", ";
  uint8_t _page, _index, _val;

  token = strtok(msg, delimiters);
  if(!token) {printf("Invalid command Ch703x.cpp : Err[1].\n"); return;}
  
  if(!strcmp(token,"I2C") || !strcmp(token, "i2c")) 
  {
    token = strtok(NULL, delimiters); //valid commands are r/w/edid/i2sEnable/i2sDisable
    if(!token) {printf("Invalid command Ch703x.cpp : Err[2].\n"); return;}
    if(!strcmp(token,"w") || !strcmp(token, "W")){
      isWriteCommand=true;
    }
    else if (!strcmp(token,"r") || !strcmp(token, "R")){
      isWriteCommand=false;
    }
    else if (!strncmp(token, "edid", sizeof("edid")-1)){
      dump_monitor_info();
      return;
    }
    else if (!strncmp(token,"i2sEnable", sizeof("i2sEnable")-1)){
      CH703X::setI2SAudio(0,0,1);
      return;
    }
    else if (!strncmp(token,"i2sDisable", sizeof("i2sDisable")-1)){
      CH703X::setI2SAudio(0,0,0);
      return;
    }    
    else
    {
      printf("Invalid command Ch703x.cpp : Err[3].\n"); return;
    }

    token = strtok(NULL, delimiters); //get the page number
    if(!token) {printf("Invalid command Ch703x.cpp : Err[4].\n"); return;}
    _page = strtol(token, NULL, 10);  //convert char to decimal
    if(_page==0 || _page>4)  {printf("Invalid command Ch703x.cpp : Err[5].\n"); return;}

    token = strtok(NULL, delimiters); //get the regiser index to write/read
    _index = strtol(token, NULL, 16);
    if(_index==0) {printf("Invalid command Ch703x.cpp : Err[6].\n"); return;}
    
    if(isWriteCommand)
    {
      token = strtok(NULL, delimiters);
      _val = strtol(token, NULL, 16);
      writeRegister(_page, _index, _val);
      printf("Write to CH7035B @ page=%d, index=%2Xh, value=%2Xh OK.\n", _page, _index, _val);
    }
    else
    {
      token = strtok(NULL, delimiters);
      uint8_t n = strtol(token, NULL, 10);
      if(n==0) {printf("Invalid command Ch703x.cpp : Err[7].\n"); return;}
      if(n>32) n = 32;
      uint8_t temp[32];
      readRegister(_page, _index, temp, n);
      printf("Read from CH7035B @ page=%d, index=%2Xh, value=", _page, _index);
      for(uint8_t i=0; i<n; i++)
      {
        printf("%2Xh ", temp[i]);
      }
      printf(".\n");
    }
  }
}

/**
* @brief  Read EDID from a HDMI sink device.
* @return true if EDID read OK
*         false if no EDID can be read
*/
bool CH703X::readEdid(void)
{
  const char es_map[16] = { 0x26,0x27,0x42,0x43,0x44,0x45,0x46,0x51};

  uint8_t i, j, ie;
  uint32_t timeout = 10000;

  for(i=0,j=0; i<16; i++,j+=8) 
  {
    setRegisterPage(1);
    hal_writeRegister(0x50, i);
    hal_writeRegister(0x4F, 0x41);
    while(timeout!=0)
    {
      setRegisterPage(1);
      if((0x01&hal_readRegister(0x4F))==0x01)
      { 
        uint8_t reg = hal_readRegister(0x50);
        if(!(0x80&reg)){
          setRegisterPage(2);
          for(ie=0; ie<8; ie++) edidBuf[j+ie] = hal_readRegister(es_map[ie]);
          break;
        }
      }
      timeout--;
    }
  }
/*
  printf("EDID raw data: " );
  for(i=0; i<128; i++){
    printf("0x%x ", edidBuf[i]);
  }
  printf("\n");
*/
  if(timeout==0)
    return false;
  else
    return true;
}

/**
* @brief  Print EDID information via Serial Monitor
* @note   Copyright 2007 Red Hat, Inc.
*         src: https://people.gnome.org/~ssp/randr/edid.h
*/
void CH703X::dump_monitor_info(void)
{
  if(readEdid()==false)
  {
    printf("Read EDID failed. There is no EDID info available.\n");
    return;
  }
    MonitorInfo *info = decode_edid (edidBuf);

    if(!info) 
    {
      printf("Is not a valid EDID information. Program exit.\n");
      return;
    }
    
    const char *str = NULL;
    int i;
    
    printf ("Checksum: %d (%s)\n",
      info->checksum, info->checksum? "incorrect" : "correct");
    printf ("Manufacturer Code: %s\n", info->manufacturer_code);
    printf ("Product Code: 0x%x\n", info->product_code);
    printf ("Serial Number: %u\n", info->serial_number);
    
    if (info->production_week != -1)
      printf ("Production Week: %d\n", info->production_week);
    else
      printf ("Production Week: unspecified\n");
    
    if (info->production_year != -1)
      printf ("Production Year: %d\n", info->production_year);
    else
      printf ("Production Year: unspecified\n");
    
    if (info->model_year != -1)
      printf ("Model Year: %d\n", info->model_year);
    else
      printf ("Model Year: unspecified\n");
    
      printf ("EDID revision: %d.%d\n", info->major_version, info->minor_version);
    
      printf ("Display is %s\n", info->is_digital? "digital" : "analog");
    if (info->is_digital)
    {
      const char *monitor_type=NULL;
      if (info->digital.bits_per_primary != -1)
          printf ("Bits Per Primary: %d\n", info->digital.bits_per_primary);
      else
          printf ("Bits Per Primary: undefined\n");
  
      switch (info->digital.interface)
      {
      case DVI: monitor_type = "DVI"; break;
      case HDMI_A: monitor_type = "HDMI-a"; break;
      case HDMI_B: monitor_type = "HDMI-b"; break;
      case MDDI: monitor_type = "MDDI"; break;
      case DISPLAY_PORT: monitor_type = "DisplayPort"; break;
      case UNDEFINED: monitor_type = "undefined"; break;
      }
      printf ("Interface: %s\n", monitor_type);
      
      printf ("RGB 4:4:4: %s\n", yesno (info->digital.rgb444));
      printf ("YCrCb 4:4:4: %s\n", yesno (info->digital.ycrcb444));
      printf ("YCrCb 4:2:2: %s\n", yesno (info->digital.ycrcb422));
    }
    else
    {
      printf ("Video Signal Level: %f\n", info->analog.video_signal_level);
      printf ("Sync Signal Level: %f\n", info->analog.sync_signal_level);
      printf ("Total Signal Level: %f\n", info->analog.total_signal_level);
      
      printf ("Blank to Black: %s\n",
        yesno (info->analog.blank_to_black));
      printf ("Separate HV Sync: %s\n",
        yesno (info->analog.separate_hv_sync));
      printf ("Composite Sync on H: %s\n",
        yesno (info->analog.composite_sync_on_h));
      printf ("Serration on VSync: %s\n",
        yesno (info->analog.serration_on_vsync));
  
      switch (info->analog.color_type)
      {
      case UNDEFINED_COLOR: str = "undefined"; break;
      case MONOCHROME: str = "monochrome"; break;
      case RGB: str = "rgb"; break;
      case OTHER_COLOR: str = "other color"; break;
      };
  
      printf ("Color: %s\n", str);
    }
    
    if (info->width_mm == -1)
      printf ("Width: undefined\n");
    else
      printf ("Width: %d mm\n", info->width_mm);
    
    if (info->height_mm == -1)
      printf ("Height: undefined\n");
    else
      printf ("Height: %d mm\n", info->height_mm);
    
    if (info->aspect_ratio > 0)
      printf ("Aspect Ratio: %f\n", info->aspect_ratio);
    else
      printf ("Aspect Ratio: undefined\n");
    
    if (info->gamma >= 0)
      printf ("Gamma: %f\n", info->gamma);
    else
      printf ("Gamma: undefined\n");
    
      printf ("Standby: %s\n", yesno (info->standby));
      printf ("Suspend: %s\n", yesno (info->suspend));
      printf ("Active Off: %s\n", yesno (info->active_off));
      
      printf ("SRGB is Standard: %s\n", yesno (info->srgb_is_standard));
      printf ("Preferred Timing Includes Native: %s\n",
        yesno (info->preferred_timing_includes_native));
      printf ("Continuous Frequency: %s\n", yesno (info->continuous_frequency));
    
      printf ("Red X: %f\n", info->red_x);
      printf ("Red Y: %f\n", info->red_y);
      printf ("Green X: %f\n", info->green_x);
      printf ("Green Y: %f\n", info->green_y);
      printf ("Blue X: %f\n", info->blue_x);
      printf ("Blue Y: %f\n", info->blue_y);
      printf ("White X: %f\n", info->white_x);
      printf ("White Y: %f\n", info->white_y);
    
      printf ("Established Timings:\n");
    
    for (i = 0; i < 24; ++i)
    {
      Timing *timing = &(info->established[i]);
      
      if (timing->frequency == 0)
          break;
      
      printf ("  %d x %d @ %d Hz\n", timing->width, timing->height, timing->frequency);
    }
    
    printf ("Standard Timings:\n");
    for (i = 0; i < 8; ++i)
    {
        Timing *timing = &(info->standard[i]);
        
        if (timing->frequency == 0)
            break;
        
        printf ("  %d x %d @ %d Hz\n",
          timing->width, timing->height, timing->frequency);
    }
    
    for (i = 0; i < info->n_detailed_timings; ++i)
    {
      DetailedTiming *timing = &(info->detailed_timings[i]);
      //const char *s;
      
      printf ("Timing%s: \n",
        (i == 0 && info->preferred_timing_includes_native)?
        " (Preferred)" : "");
      printf ("  Pixel Clock: %d\n", timing->pixel_clock);
      printf ("  H Addressable: %d\n", timing->h_addr);
      printf ("  H Blank: %d\n", timing->h_blank);
      printf ("  H Front Porch: %d\n", timing->h_front_porch);
      printf ("  H Sync: %d\n", timing->h_sync);
      printf ("  V Addressable: %d\n", timing->v_addr);
      printf ("  V Blank: %d\n", timing->v_blank);
      printf ("  V Front Porch: %d\n", timing->v_front_porch);
      printf ("  V Sync: %d\n", timing->v_sync);
      printf ("  Width: %d mm\n", timing->width_mm);
      printf ("  Height: %d mm\n", timing->height_mm);
      printf ("  Right Border: %d\n", timing->right_border);
      printf ("  Top Border: %d\n", timing->top_border);
      switch (timing->stereo)
      {
      case NO_STEREO:   str = "No Stereo"; break;
      case FIELD_RIGHT: str= "Field Sequential, Right on Sync"; break;
      case FIELD_LEFT:  str = "Field Sequential, Left on Sync"; break;
      case TWO_WAY_RIGHT_ON_EVEN: str = "Two-way, Right on Even"; break;
      case TWO_WAY_LEFT_ON_EVEN:  str = "Two-way, Left on Even"; break;
      case FOUR_WAY_INTERLEAVED:  str = "Four-way Interleaved"; break;
      case SIDE_BY_SIDE:          str = "Side-by-Side"; break;
      }
      printf ("  Stereo: %s\n", str);
      
      if (timing->digital_sync)
      {
          printf ("  Digital Sync:\n");
          printf ("    composite: %s\n", yesno (timing->digital.composite));
          printf ("    serrations: %s\n", yesno (timing->digital.serrations));
          printf ("    negative vsync: %s\n",
            yesno (timing->digital.negative_vsync));
          printf ("    negative hsync: %s\n",
            yesno (timing->digital.negative_hsync));
      }
      else
      {
          printf ("  Analog Sync:\n");
          printf ("    bipolar: %s\n", yesno (timing->analog.bipolar));
          printf ("    serrations: %s\n", yesno (timing->analog.serrations));
          printf ("    sync on green: %s\n", yesno (
          timing->analog.sync_on_green));
      }
    }
    printf ("Detailed Product information:\n");
    printf ("  Product Name: %s\n", info->dsc_product_name);
    printf ("  Serial Number: %s\n", info->dsc_serial_number);
    printf ("  Unspecified String: %s\n", info->dsc_string);
}

/**
* @brief Freeze image on DVI/VGA/HDTV
* @param Set 1 to freeze
*        Set 0 to release
*/
void CH703X::freezeImage(bool freeze)
{
  uint8_t REG_R1_09h;
  readRegister(1, 0x09, &REG_R1_09h, 1);

  if(freeze)
    REG_R1_09h |=(1<<6);
  else
    REG_R1_09h &=~(1<<6);

    writeRegister(1, 0x09, REG_R1_09h);
}

/**
* @brief Bypass frame scaler enable / disable
* @param Set 1 to bypass
*        Set 0 to enable frame scaler
* 
*/
void CH703X::frameScaler(bool bypass)
{
  uint8_t REG_R1_09h;
  readRegister(1, 0x09, &REG_R1_09h, 1);

  if(bypass)
    REG_R1_09h |=(1<<5);
  else
    REG_R1_09h &=~(1<<5);

    writeRegister(1, 0x09, REG_R1_09h);  
}

/**
* @brief Display a test pattern directly from CH703X HDMI encoder
* @param sw is the switch for ON(1), OFF(0)
* @param pattern valid values are 0(External data), 1(White), 2(Vertical ramp),
*        3(Horizontal ramp), 4(Color bar), 7(production test pattern),
*        11(sine wave output for DAC test), 13(ramp output for DAC test)
*/
void CH703X::testPattern(bool sw, uint8_t pattern)
{
  if(sw)
    writeRegister(1, 0x7F, 0x10|pattern);
  else
    writeRegister(1, 0x7F, 0x00);
}

/**
 * @brief Set horizontal total pixels for input signal
 * @param hti is the horizontal total pixels
 */
void CH703X::setInputHorizontalTotal(uint16_t hti)
{
  uint8_t REG_R1_0Bh;
  readRegister(1, 0x0B, &REG_R1_0Bh, 1);

  uint8_t hti_hibyte = hti>>8;				//HTI[11:8]
  hti_hibyte&=0x0F;
  REG_R1_0Bh |=(hti_hibyte<<3);
  //setRegisterPage(1);
  hal_writeRegister(0x0B, REG_R1_0Bh);		//HTI[11:8] 
  hal_writeRegister(0x0D, (uint8_t)hti);	//HTI[7:0]
}

/**
 * @brief Set horizontal front porch for input signal
 * @param hoi is the horizontal sync offset, also known as front porch
 */
void CH703X::setInputHsyncFrontPorch(uint16_t hoi)
{
  uint8_t REG_R1_0Eh;
  readRegister(1, 0x0E, &REG_R1_0Eh, 1);

  uint8_t hoi_hibyte = hoi>>8;				//HOI[10:8]
  hoi_hibyte&=0x07;							//0b111 restriction
  REG_R1_0Eh|=hoi_hibyte;
  //setRegisterPage(1);
  hal_writeRegister(0x0E, REG_R1_0Eh);		//HOI[10:8]
  hal_writeRegister(0x0F, (uint8_t)hoi);	//HOI[7:0]
}

/**
 * @brief Set horizontal active pixel for input signal
 * @param hai is the horizontal active width in pixel clock
 */
void CH703X::setInputHsyncActiveWidth(uint16_t hai)
{
  uint8_t REG_R1_0Bh;
  readRegister(1, 0x0B, &REG_R1_0Bh, 1);

  uint8_t hai_hibyte = hai>>8;				//HAI[10:8]
  hai_hibyte&=0x07;							//0b111 restriction
  REG_R1_0Bh|=hai_hibyte;
  //setRegisterPage(1);
  hal_writeRegister(0x0B, REG_R1_0Bh);		//HAI[10:8]
  hal_writeRegister(0x0C, (uint8_t)hai);	//HAI[7:0]  
}

/**
 * @brief Set horzonital pulse width for input signal
 * @param hwi is the horizontal pulse width in pixel clock
 */
void CH703X::setInputHsyncPulseWidth(uint16_t hwi)
{
  uint8_t REG_R1_0Eh;
  readRegister(1, 0x0E, &REG_R1_0Eh, 1);

  uint8_t hwi_hibyte = hwi>>8;				//HWI[10:8]
  hwi_hibyte&=0x07;
  REG_R1_0Eh |=(hwi_hibyte<<3);
  //setRegisterPage(1);
  hal_writeRegister(0x0E, REG_R1_0Eh);		//HWI[10:8]
  hal_writeRegister(0x10, (uint8_t)hwi);	//HWI[7:0]  
}

/**
* @brief Set vertical total line number for input signal
* @param vti is the vertical total line number
*/
void CH703X::setInputVerticalTotal(uint16_t vti)
{
	uint8_t REG_R1_11h;
	readRegister(1, 0x11, &REG_R1_11h, 1);

	uint8_t vti_hibyte = vti >> 8;			//VTI[10:8]
	vti_hibyte &= 0x07;
	REG_R1_11h |= (vti_hibyte << 3);
	//setRegisterPage(1);
	hal_writeRegister(0x11, REG_R1_11h);	//VTI[10:8]
	hal_writeRegister(0x13, (uint8_t)vti);	//VTI[7:0]
}

/**
 * @brief Set vertical active height for input signal
 * @param vai is the vertical active height in line number
 */
void CH703X::setInputVsyncActiveHeight(uint16_t vai)
{
  uint8_t REG_R1_11h;
  readRegister(1, 0x11, &REG_R1_11h, 1);

  uint8_t vai_hibyte = vai>>8;			//VAI[10:8]
  vai_hibyte &= 0x07;
  REG_R1_11h|=vai_hibyte;
  //setRegisterPage(1);
  hal_writeRegister(0x11, REG_R1_11h);   //VAI[10:8]
  hal_writeRegister(0x12, (uint8_t)vai); //VAI[7:0]
}

/**
* @brief Set vertical front porch for input signal
* @param voi is the vertical sync offset, also known as front porch
*/
void CH703X::setInputVsyncFrontPorch(uint16_t voi)
{
	uint8_t REG_R1_14h;
	readRegister(1, 0x14, &REG_R1_14h, 1);

	uint8_t voi_hibyte = voi>>8;			//VOI[10:8]
	voi_hibyte &= 0x07;	
	REG_R1_14h |= voi_hibyte;
	//setRegisterPage(1);
	hal_writeRegister(0x14, REG_R1_14h);	//VOI[10:8]
	hal_writeRegister(0x15, (uint8_t)voi);	//VOI[7:0]
}

/**
* @brief Set vertical pulse width for input signal
* @param hwi is the vertical pulse width in line number
*/
void CH703X::setInputVsyncPulseWidth(uint16_t vwi)
{
	uint8_t REG_R1_14h;
	readRegister(1, 0x14, &REG_R1_14h, 1);

	uint8_t vwi_hibyte = vwi >> 8;				//VWI[10:8]
	vwi_hibyte &= 0x07;
	REG_R1_14h |= (vwi_hibyte << 3);
	hal_writeRegister(0x14, REG_R1_14h);		//VWI[10:8]
	hal_writeRegister(0x16, (uint8_t)vwi);	//VWI[7:0]
}

/**
* @brief Set input sync polarity for hsync, vsync, and de
* @param hsync polarity, 1 for high active, 0 for low active
* @param vsync polarity, 1 for high active, 0 for low active
* @param de polarity, 1 for high active, 0 for low active
*/
void CH703X::setInputSyncPolarity(bool hsync, bool vsync, bool de)
{
  uint8_t REG_R1_19h;
  readRegister(1, 0x19, &REG_R1_19h, 1);

  (hsync)?(REG_R1_19h|=(1<<5)):(REG_R1_19h&=~(1<<5));
  (vsync)?(REG_R1_19h|=(1<<4)):(REG_R1_19h&=~(1<<4));
  (de) ? (REG_R1_19h &= ~(1 << 3)):(REG_R1_19h |= (1 << 3));

  hal_writeRegister(0x19, REG_R1_19h);
}

/**
 * @brief Set input signal pixel clock frequency
 * @param pclk in kHz (eg 50MHz, GCLKFREQ[17:0]=50000
 */
void CH703X::setInputPclkFrequency(uint32_t pclk)
{
  uint8_t REG_R1_19h;
  readRegister(1, 0x19, &REG_R1_19h, 1);

  uint8_t pclk_bit17_16 = pclk>>16;	
  pclk_bit17_16&=0x03;
  REG_R1_19h|=pclk_bit17_16;

  hal_writeRegister(0x19, REG_R1_19h);
  hal_writeRegister(0x1A, (uint8_t)(pclk>>8));
  hal_writeRegister(0x1B, (uint8_t)pclk);
}

/**
 * @brief Set horizontal total pixels for output signal
 * @param hto is the horizontal total pixels
 */
void CH703X::setOutputHorizontalTotal(uint16_t hto)
{
  uint8_t REG_R1_1Fh;
  readRegister(1, 0x1F, &REG_R1_1Fh, 1);

  uint8_t hto_hibyte = hto>>8;  //HTO[11:8]
  hto_hibyte&=0x0F;
  REG_R1_1Fh|=(hto_hibyte<<3);
  writeRegister(1, 0x1F, REG_R1_1Fh);   //HTO[11:8]
  writeRegister(1, 0x21, (uint8_t)hto); //HTO[7:0]
}

/**
* @brief Set horizontal front porch for output signal
* @param hoo is the horizontal sync offset, also known as front porch
*/
void CH703X::setOutputHsyncFrontPorch(uint16_t hoo)
{
  uint8_t REG_R1_22h;
  readRegister(1, 0x22, &REG_R1_22h, 1);

  uint8_t hoo_hibyte = hoo>>8;  //HOO[10:8]
  hoo_hibyte&=0x07;

  REG_R1_22h|=hoo_hibyte;
  writeRegister(1, 0x22, REG_R1_22h);   //HOO[10:8]
  writeRegister(1, 0x23, (uint8_t)hoo); //HOO[7:0]
}

/**
 * @brief Set horizontal active pixel for output signal
 * @param hao is the horizontal active width in pixel clock
 */
void CH703X::setOutputHsyncActiveWidth(uint16_t hao)
{
  uint8_t REG_R1_1Fh;
  readRegister(1, 0x1F, &REG_R1_1Fh, 1);

  uint8_t hao_hibyte = hao>>8;  //HAO[10:8]
  hao_hibyte&=0x07;             //0b111 restriction
  REG_R1_1Fh|=hao_hibyte;
  writeRegister(1, 0x1F, REG_R1_1Fh);   //HAO[10:8]
  writeRegister(1, 0x20, (uint8_t)hao); //HAO[7:0]  
}

/**
* @brief Set I2S audio format and set it enable or disable
* @param len is the length of I2S data bit, 0=16bits, 1=20bits, or 2=24bits.
* @param fmt is the format, 00:standard, 01:right-justified, 10:left-justified
* @param en is the enable flag, '1' to enable, '0' to disable
* @note: Example to set an I2S standard format in 16-bit data length to enable audio
*        setI2SAudio(0, 0, 1);
*        Example to disable I2S audio
*        setI2SAudio(xx, xx, 0);  //xx's are don't care values when en=0, they can be zero
* @note: Relevant registers
*        Page 1, R1_07h[6], I2S_PD, 1:power down, 0:power on
         Page 1, register 0x1E:
         I2SPOL,   I2S_SPDIFB, INTLC,    I2S_LENGTH, I2SFMT,
         Page 2, register 0x4F:
         R2_4Fh[7:6] with values dependent on I2S length
*/
void CH703X::setI2SAudio(uint8_t len, uint8_t fmt, bool en)
{
  uint8_t REG_R1_07h, REG_R1_1Eh, REG_R2_4Fh;
  
  readRegister(1, 0x07, &REG_R1_07h, 1);
  
  if(en)
  {
    //readRegister(1, 0x07, &REG_R1_07h, 1);
    readRegister(1, 0x1E, &REG_R1_1Eh, 1);
    readRegister(2, 0x4F, &REG_R2_4Fh, 1);
    
    REG_R1_1Eh |= (0x40|(len<<2)|fmt);  //0x40 to set bit 6 '1' for I2S format
    writeRegister(1, 0x1E, REG_R1_1Eh);
    
    if(len==0)
      writeRegister(2, 0x4F, REG_R2_4Fh|(3<<6));  //set MULTIDATA[1:0]
    else if (len==1)
      writeRegister(2, 0x4F, (REG_R2_4Fh|(1<<7))&0xBF);
    else if (len==2)
      writeRegister(2, 0x4F, (REG_R2_4Fh&0x3F));
      
    REG_R1_07h &= 0xBF; //R1_07h[6] set '0' to power up I2S audio
  }
  else  //disable I2S audio
  {
    REG_R1_07h |= 0x40;  //R1_07h[6] set '1' to power down I2S audio
  }
  writeRegister(1, 0x07, REG_R1_07h);
}


       
