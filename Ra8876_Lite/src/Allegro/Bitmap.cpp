#include "Bitmap.h"

static void drawSquare(BITMAP *bmp, int x1, int y1, int x2, int y2, int color, bool fill);

/**
 * @brief	Constructor for BITMAP class
 * @param	width & height represent the dimensions of this BITMAP
 * @note	Memory is allocated in SDRAM connected to Ra8876 for this BITMAP.
 *			The memory allocated is not cleared on creation, so it will probably contain garbage: 
 *			you should clear the BITMAP before using it. This routine always use the 
 *			global color depth specified by calling allegro_init() in initialization. 
 */
BITMAP:: BITMAP (uint16_t width, uint16_t height)
{
	w = width;
	h = height;
	uint8_t bpp = ra8876lite.getColorDepth();	
	//allocate memory from Ra8876's SDRAM
	int32_t offset = mmu->mem_malloc((uint32_t)width*height*bpp);	
	if(offset<0){
		//exception.ex_throw("BITMAP::create_bitmap err -2!");
		printf("BITMAP::create_bitmap err -2!\n");
	}
	else
	{
		thisBitmapAddress = offset;
		//printf("#BITMAP physical address %d\n", thisBitmapAddress);
	}
	
	clipping = false;
	cl = 0; 
	cr = width-1;//cr = VIRTUAL_W-1;
	ct = 0; 
	cb = height-1;//cb = VIRTUAL_H-1;
}

/**
 * @brief	Destructor for BITMAP class
 * @note	Memory freed from heap and SDRAM of RA8876
 */
BITMAP::~BITMAP()
{
	mmu->mem_free(this->thisBitmapAddress);	//free memory from SDRAM
	//printf("This BITMAP deleted.\n");
}

void BITMAP::setClipState(bool state)
{
	if(state==true)
	{
		clipping = true;
	}
	else
	{
		clipping = false;
		//reset clipping rectangle to full bitmap area
		cl = 0;
		cr = w-1;//cr = VIRTUAL_W-1;
		ct = 0;
		cb = h-1;//cb = VIRTUAL_H-1;
	}
}

/**
 * @brief	This function sets the clipping rectangle for this bitmap.
 * @param	x1, y1 indicate the top left corner (values inclusive).
 * @param	x2, y2 indicate the bottom right corner (values inclusive).
 * @note	Each bitmap has an associated clipping rectangle, which is the area of the
 *			image that it is ok to draw onto. Nothing will be drawn to positions outside
 *			this space. Drawing operations will be performed on the bitmap
 *			as long as the first coordinates of its clipping rectangle 
 *			are not greater than the second coordinates and its intersection with 
 *			the actual image is non-empty. If either condition is not fulfilled, 
 *			drawing will be turned off for the bitmap, 
 *			e.g. set_clip_rect(bmp, 0, 0, -1, -1); //disable drawing on bmp 
 */
void BITMAP::setClipRect(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2)
{
	if((x1 >= x2) || (y1 >= y2)) return;
	
	if((x1 >= w-1) || (y1 >= h-1)) return;
	
	cl = x1;
	if(x2>w-1) x2=w-1;
	cr = x2;
	ct = y1;
	if(y2>h-1) y2=h-1;
	cb = y2;
}

/**
 * @brief	Return clipping rectangle boundary.
 * @param	*x1, *y1 are pointers to values holding clipping left and clipping top boundary.
 * @param	*x2, *y2 are pointers to values holding clipping right and clipping bottom boundary.
 *			
 */
void BITMAP::getClipRect(uint16_t *x1, uint16_t *y1, uint16_t *x2, uint16_t *y2)
{
	*x1 = cl;
	*x2 = cr;
	*y1 = ct;
	*y2 = cb;
}

/**
 * @brief	Creates a BITMAP of size width x height. 
 * @param	width, height represent the dimension of this BITMAP
 * @return	Returns a pointer to the created BITMAP, or NULL if the BITMAP could not be created. 
 *			Remember to free this BITMAP later to avoid memory leaks.
 * @note	Comply with legacy Allegro 4.4.x
 */
BITMAP* create_bitmap(int width, int height)
{
	BITMAP* pBitmap = new BITMAP((uint16_t)width, (uint16_t)height);
	
	if(pBitmap)
		return pBitmap;
	else
		return NULL;
}

/**
 * @brief	Create a BITMAP and then fill it up with a picture from MCU's Flash.
 * @param	width, height indicate the dimension of the picture embedded in MCU's Flash.
 * @param	*flash is a void pointer to a static array of 8-bit or 16-bit data in MCU's Flash.
 * @return	Returns a pointer to the created BITMAP, or NULL if the BITMAP could not be created.
 *			Remember to free this BITMAP later to avoid memory leaks. 
 */
BITMAP* load_flash(int width, int height, const void *flash)
{
	BITMAP* pBitmap = new BITMAP((uint16_t)width, (uint16_t)height);
	
	if(!pBitmap) return NULL;	//failed to allocate memory from heap or SDRAM
	
	uint8_t bpp = ra8876lite.getColorDepth();
	uint32_t lnOffset = pBitmap->getAddress() / (VIRTUAL_W*bpp);
	//printf("lnOffset calling load_bitmap_flash() = %d.\n", lnOffset);
	size_t byte_count = (size_t) pBitmap->getWidth() * pBitmap->getHeight() * bpp;
	//printf("byte_count calling load_bitmap_flash() = %d.\n", byte_count);
	ra8876lite.canvasWrite(flash, lnOffset, byte_count);
	
	return pBitmap;
	
}

/**
 * @brief	Load a picture in binary format from SD card to SDRAM.<br>
 *			The binary file is generated by RAiO tool. A BITMAP pointer is returned as the handler.<br>
 * @param	width, height indicate the dimension of the picture.
 * @param	*pFilename is a pointer to the filename.
 * @return	Returns a pointer to the created BITMAP, or NULL if the BITMAP could not be created.<br>
 *			Remember to free this BITMAP if it is no longer required to avoid memory leaks.  
 * @note	Because there is no width and height information available from the binary file generated
 *			by RAiO tool so we need to specify them as arguments.
 */
#if defined (LOAD_SD_LIBRARY) || defined (LOAD_SDFAT_LIBRARY)
BITMAP* load_binary_sd(int width, int height, const char *pFilename)
{
	BITMAP* pBitmap = new BITMAP((uint16_t)width, (uint16_t)height);
	
	if(!pBitmap) return NULL;	//failed to allocate memory from heap or SDRAM
	
	uint8_t bpp = ra8876lite.getColorDepth();
	uint32_t lnOffset = pBitmap->getAddress() / (VIRTUAL_W*bpp);
	
	ra8876lite.canvasWrite(width, height, pFilename, lnOffset);
	
	return pBitmap;
}
#endif

/**
 * @brief	Load a picture in binary format from external serial flash to SDRAM.<br>
 *			The binary file is generated by RAiO tool and preloaded to the external serial flash onboard of ArduoHDMI.<br>
 *			A BITMAP pointer is returned as the handler.<br>
 * @param	picture_width is the pixel width of the image.
 * @param	picture_height is the image height in line.
 * @param	src_addr is the Serial flash DMA source address. This is obtained from RAiO Image_AP tool.
 * @return	Returns a pointer to the created BITMAP, or NULL if the BITMAP could not be created.<br>
 *			Remember to free this BITMAP if it is no longer required to avoid memory leaks.		
 */
BITMAP* load_binary_xflash(int picture_width, int picture_height, long src_addr)
{
	BITMAP* pBitmap = new BITMAP((uint16_t)picture_width, (uint16_t)picture_height);
	if(!pBitmap) return NULL;	//failed to allocate memory from heap or SDRAM
	
	//change to linear mode
	ra8876lite.canvasLinearModeSet();
	
	ra8876lite.dmaDataLinearTransfer(pBitmap->getAddress(), picture_width, picture_height, src_addr);
	//printf("desAddr = %d, w = %d, h = %d, src_addr = %d\n", pBitmap->getAddress(), picture_width, picture_height, src_addr);
	//restore to block mode
	ra8876lite.canvasBlockModeSet();
	
	return pBitmap;
}

/**
 * @brief	Destroy a BITMAP from heap and RA8876's SDRAM.
 * @param	*bitmap is a pointer to the BITMAP to be destroyed.
 * @note	Comply with legacy Allegro 4.4.x
 */
void destroy_bitmap(BITMAP *bitmap)
{
	if(!bitmap) return;
	delete bitmap;
}

/**
 * @brief	Turns on (if state is non-zero) or off (if state is zero) clipping for the specified bitmap.
 * @param	*bitmap is a pointer to the BITMAP to set
 * @param	state = 1 to turn on
 *			state = 0 to turn off
 */
void set_clip_state(BITMAP *bitmap, int state)
{
	bitmap->setClipState((bool)state);
}

/**
 * @brief	Returns non-zero if clipping is turned on for the specified bitmap and zero otherwise.
 * @return	'1' if clipping has been turned on.<br>
 *			'0' is clipping is off.
 */
int	get_clip_state(BITMAP *bitmap)
{
	return ((int)bitmap->getClipState());
}

/**
 * @brief	This function is the same as <br>
 *			BITMAP::setClipRect(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2).
 */
void set_clip_rect(BITMAP *bitmap, int x1, int y1, int x2, int y2)
{
	bitmap->setClipRect((uint16_t)x1,(uint16_t)y1,(uint16_t)x2,(uint16_t)y2);
}

/*
 * @brief	This function is the same as <br>
 *			BITMAP::getClipRect(uint16_t *x1, uint16_t *y1, uint16_t *x2, uint16_t *y2).
 * @note	Example : <br>
 *			uint16_t left,right,top,bottom;
 *			get_clip_rect(screen, &left, &top, &right, &bottom);
 */
void get_clip_rect(BITMAP *bitmap, uint16_t *x1, uint16_t *y1, uint16_t *x2, uint16_t *y2)
{
	bitmap->getClipRect(x1,y1,x2,y2);
}

/**
 * @brief	Local function to draw and fill a rectangle with solid color or drawing the frame only.
 *			Use as the calling function for rectfill() & rect()
 */
static void drawSquare(BITMAP *bmp, int x1, int y1, int x2, int y2, int color, bool fill)
{
	 if(bmp==NULL) return;
	 if(x1==x2 || y1==y2) return;	//a rectangle cannot be of zero width/height
	 
	 uint16_t left,right,top,bottom;
	 uint16_t cl,cr,ct,cb;
	 bmp->getClipRect(&cl, &ct, &cr, &cb);	//get clipping rectangle first 
	 //printf("Clipping rectangle = left %d, right %d, top %d, bottom %d\n", cl, cr, ct, cb);
 
	if(x2>x1)
	{
		right = x2; 
		left = x1;
	}else
	{
		right = x1; 
		left = x2;
	}
	
	if(y2>y1)
	{
		top = y1; 
		bottom = y2;
	}else
	{
		top = y2; 
		bottom = y1;
	}
	
	left  	= constrain(left, 	cl, cr);	//values cl, cr are inclusive.
	right 	= constrain(right,	cl, cr);
	top		= constrain(top,  	ct, cb);
	bottom	= constrain(bottom, ct, cb);
  
	//printf("Clipping rectangle is now: left %d, right %d, top %d, bottom %d\n", left, right, top, bottom);
	
	Color _color(color);
	
	if(fill)
	{
		//ra8876lite.bteSolidFill(bmp->getAddress(),left,top,right-left+1,bottom-top+1,_color);
		ra8876lite.canvasImageStartAddress(bmp->getAddress());
		ra8876lite.drawSquareFill(left, top, right, bottom, _color);
		ra8876lite.canvasImageStartAddress(CANVAS_OFFSET);
	}
	else
	{
		ra8876lite.canvasImageStartAddress(bmp->getAddress());
		ra8876lite.drawSquare(left, top, right, bottom, _color);
		ra8876lite.canvasImageStartAddress(CANVAS_OFFSET);
	}
}

/**
 * @brief	Draws a solid, filled rectangle with two points as its opposite corners. 
 * @param	*bmp is a pointer to the BITMAP to draw this rectangle.
 * @param	x1,y1 are the starting coordinates
 * @param	x2,y2 are the ending coordinates
 * @param	color in integer (not sf::Color object)
 * @note	Example: <br>
 *			rectfill(screen, 100, 200, 150, 230, 255<<24);	
 *			//draw a rectangle of size 50*30 of red color starting from (100,200)
 */
void rectfill(BITMAP *bmp, int x1, int y1, int x2, int y2, int color)
{
	if(bmp==screen)
	{
		drawSquare(screen, x1, y1, x2, y2, color, true);
	}
	else
	{//pixel-by-pixel draw routine
		
	}
}

void rect(BITMAP *bmp, int x1, int y1, int x2, int y2, int color)
{
	if(bmp==screen)
	{
		drawSquare(screen, x1, y1, x2, y2, color, false);
	}
	else
	{//pixel-by-pixel draw routine
		
	}
}

/**
 * @brief	Clears the bitmap to color black.
 * @param	*bitmap points to the BITMAP to clear.
 */
void clear_bitmap(BITMAP *bitmap)
{
	clear_to_color(bitmap, 0);
}

/**
 * @brief	Clears the bitmap to the specified color.
 * @param	*bitmap points to the BITMAP to clear.
 * @param	color represents the color to fill in integer.
 */
void clear_to_color(BITMAP *bitmap, int color)
{
	sf::Color color_to_clear(color);
	//data in BITMAP rectangle re-arranged to fit the full virtual width (VIRTUAL_W).
	//e.g. BITMAP of size 300x500*bpp converted to 800*188*bpp; 800=VIRTUAL_W, 188 is calculated from the formula (300*500 + 800)/800
	uint16_t bte_height = ra8876lite.getColorDepth()*(bitmap->getWidth() * bitmap->getHeight() + VIRTUAL_W)/VIRTUAL_W;
	
	ra8876lite.bteSolidFill(bitmap->getAddress(),0,0,VIRTUAL_W,bte_height,color_to_clear);
}


